+package org.jpeek.calculus.eo

# ===================================================================
# Class object
# name - class name
# methods - array of method objects
# atts - array of attrribute objects of the class
[name methods atts] > class
  name > @

# ===================================================================
# Method object
# name - method name
# args - array of argument types of the method
# atts - array of attrribute objects used by method
# calls - array of method calls of the method
[name args atts attsGet attsPut calls] > method
  name > @

  [a] > isUsingAttribute
    [i imax] > attsLoop
      if. > @
        i.geq imax
        false
        if.
          eq.
            (^.^.atts.get i).name
            ^.a.name
          true
          attsLoop
            i.add 1
            imax
    attsLoop > @
      0
      ^.atts.length

  [m] > isCallsMethod
    [i imax] > mLoop
      if. > @
        i.geq imax
        false
        if.
          eq.
            ^.^.calls.get i
            ^.m.name
          true
          mLoop
            i.add 1
            imax
    mLoop > @
      0
      ^.calls.length

  [att] > accessesAtt
    greater. > @
      count
        ^.atts
        att
      0

  [method] > callsMethod
    greater. > @
      count
        ^.calls
        method
      0

  [method] > accessSameAttribute
    rec 0 > @

    [currIndex] > rec
      ^.method.atts.get currIndex > currAtt
      if. > @
        currIndex.geq (^.method.atts.length)
        false
        or.
          ^.^.accessesAtt currAtt
          rec (currIndex.add 1)

# ===================================================================
# Attribute object
# name - attribute name
[name] > att
  name > @

# ===================================================================
# Index pair
[i j] > iPair
  [pairArray] > inArray
    [i imax] > paLoop
      if. > @
        i.geq imax
        false
        or.
          ^.^.eq
            ^.pairArray.get i
          paLoop
            i.add 1
            imax

    and. > @
      pairArray.length.greater 0
      paLoop
        0
        pairArray.length

  [p] > eq
    or. > @
      and.
        eq.
          ^.i
          p.i
        eq.
          ^.j
          p.j
      and.
        eq.
          ^.i
          p.j
        eq.
          ^.j
          p.i

  not. > @
    eq.
      i
      j

# ===================================================================
# is Attribute used by method
# a - attribute object
# m - method object
[a m] > isAUsedByM
  [i imax] > attributeLoop
    if. > @
      i.geq imax
      false
      if.
        eq.
          (^.m.atts.get i).name
          ^.a.name
        true
        attributeLoop
          i.add 1
          imax
  attributeLoop > @
    0
    m.atts.length

# ===================================================================
# Has or not 2 methods of a class direct connectivity(both methods are using same attribute(s))
# m1, m2 method objects
[m1 m2] > hasDirectConnectivity
  [i imax j jmax] > attLoop
    if. > @
      i.geq imax
      false
      if.
        j.geq jmax
        attLoop
          i.add 1
          imax
          0
          jmax
        if.
          eq.
            name.
              ^.m1.atts.get
                i
            name.
              ^.m2.atts.get
                j
          true
          attLoop
            i
            imax
            j.add 1
            jmax
  if. > @
    and.
      m1.atts.length.greater 0
      m2.atts.length.greater 0
    attLoop
      0
      m1.atts.length
      0
      m2.atts.length
    false

# ===================================================================
[methods] > getDirectConnectPairs
  [i j imax] > dcpLoop
    if. > @
      i.geq
        imax.sub 1
      *
      if.
        j.geq
          imax
        dcpLoop
          i.add 1
          i.add 2
          imax
        appendAll.
          dcpLoop
            i
            j.add 1
            imax
          if.
            hasDirectConnectivity
              ^.methods.get i
              ^.methods.get j
            *
              iPair i j
            *
  if. > @
    less.
      methods.length
      2
    *
    dcpLoop
      0
      1
      methods.length

# ===================================================================
[pairs] > getAllPairs
  [] > newPairs!
    [i j imax] > npLoop
      (^.^.pairs.get i) > pairI!
      (^.^.pairs.get j) > pairJ!
      if. > newPair!
        eq.
          pairI.i
          pairJ.i
        iPair
          pairI.j
          pairJ.j
        if.
          eq.
            pairI.j
            pairJ.j
          iPair
            pairI.i
            pairJ.i
          if.
            eq.
              pairI.i
              pairJ.j
            iPair
              pairI.j
              pairJ.i
            if.
              eq.
                pairI.j
                pairJ.i
              iPair
                pairI.i
                pairJ.j
              iPair
                i
                i
      if. > @
        geq.
          i
          imax.sub
            1
        *
        if.
          j.geq imax
          npLoop
            i.add 1
            i.add 2
            imax
          appendAll.
            npLoop
              i
              j.add 1
              imax
            if.
              newPair
              *
                newPair
              *

    if. > @
      ^.pairs.length.less 2
      *
      npLoop
        0
        1
        ^.pairs.length

  [] > joinedPairs!
    [i imax] > joinLoop
      (^.^.newPairs.get i) > pairI!
      joinLoop > otherPairs!
        i.add 1
        imax
      if. > @
        i.geq imax
        *
        appendAll.
          otherPairs
          if.
            and.
              pairI
              not.
                or.
                  pairI.inArray
                    otherPairs
                  pairI.inArray
                    ^.^.pairs
            *
              pairI
            *
    if. > @
      ^.newPairs.length.eq 0
      ^.pairs
      joinLoop
        0
        ^.newPairs.length
  if. > @
    or.
      newPairs.length.eq 0
      joinedPairs.length.eq 0
    pairs
    getAllPairs
      appendAll.
        pairs
        joinedPairs

# ===================================================================
[methods] > getConnectedPairs
  getDirectConnectPairs > dcp!
    methods
  if. > @
    less.
      methods.length
      2
    *
    getAllPairs dcp

# ===================================================================
# Checks if a pair of methods is a pair in which one calls the other
# m1, m2 method objects
# Result is EObool object
[m1 m2] > isCallPair
  or. > @
    m1.isCallsMethod m2
    m2.isCallsMethod m1

# ===================================================================
#  Creates an array of  iPairs of methods  in which one calls the other directly or or through other methods
#  methods - array of method objects
#  Result is EOarray of iPar objects
[methods] > getCallPairs
  [i j imax] > directCalls
    ^.methods.get i > methodI
    ^.methods.get j > methodJ
    iPair i j > newPair
    directCalls > restArray!
      i
      j.add 1
      imax

    if. > @
      i.geq (imax.sub 1)
      *
      if.
        j.geq imax
        directCalls
          i.add 1
          i.add 2
          imax
        restArray.appendAll
          if.
            and.
              isCallPair methodI methodJ
              not.
                newPair.inArray restArray
            *
              newPair
            *
  if. > @
    less.
      methods.length
      2
    *
    getAllPairs
      directCalls 0 1 methods.length
# ===================================================================
# Get an array of iPair objects representing Weak-connection graph for OCC metric
[class] > occGraph
  getCallPairs > callPairs!
    class.methods
  getDirectConnectPairs > dcp!
    class.methods

  [i imax] > arrLoop
    arrLoop > restArray!
      i.add 1
      imax
    ^.dcp.get i > currentPair
    if. > @
      i.geq imax
      ^.callPairs
      appendAll.
        restArray
        if.
          currentPair.inArray restArray
          *
          *
            currentPair

  if. > @
    callPairs.length.eq 0
    dcp
    if.
      dcp.length.eq 0
      callPairs
      arrLoop 0 dcp.length
# ===================================================================
[pairArray index] > countPairsWithIndex
  reduce. > @
    pairArray
    0
    []
      [accum current] > reduce
        if. > @
          or.
            ^.^.index.eq (current.i)
            ^.^.index.eq (current.j)
          accum.add 1
          accum

# ===================================================================
#  maximum possible number of direct or indirect connections
#  methods - array of method objects
[methods] > np
  if. > @
    methods.length.less 2
    0
    div.
      mul.
        methods.length
        sub.
          methods.length
          1
      2
# ===================================================================
#  number of direct connections
#  methods - array of method objects
[methods] > ndc
  [i j imax] > methodsLoop
    if. > @
      i.geq (imax.sub 1)
      0
      if.
        j.geq imax
        methodsLoop
          i.add 1
          i.add 2
          imax
        add.
          if.
            hasDirectConnectivity
              ^.methods.get
                i
              ^.methods.get
                j
            1
            0
          methodsLoop
            i
            j.add 1
            imax
  if. > @
    methods.length.less 2
    0
    methodsLoop
      0
      1
      methods.length
# ===================================================================
[arr element] > count
  reduce. > @
    arr
    0
    []
      [accum current] > reduce
        if. > @
          eq.
            current
            ^.^.element
          add.
            accum
            1
          accum
# ===================================================================
[arr] > unique
  reduce. > @
    arr
    *
    []
      [accum current] > reduce
        if. > @
          greater.
            count
              accum
              current
            0
          accum
          append.
            accum
            current
# ===================================================================
[arr position] > removeat
  merge > @
    slice
      arr
      0
      position
    slice
      arr
      add.
        position
        1
      arr.length
# ===================================================================
[arr start end] > slice
  subSlice > @
    arr
    *
    start
    end

  [arr accum start end] > subSlice
    if. > @
      less.
        start
        end
      subSlice
        arr
        append.
          accum
          get.
            arr
            start
        add.
          start
          1
        end
      accum
# ===================================================================
[arr1 arr2] > merge
  reduce. > @
    arr2
    arr1
    []
      [accum current] > reduce
        append. > @
          accum
          current
